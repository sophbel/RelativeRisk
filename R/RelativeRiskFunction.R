#' Generate Pairwise Matrix for Relative Risk Calculation
#' 
#' This function generates pairwise matrices from metadata file. 
#'
#' @param meta_table metadata file 
#' @param bactdate_tree tree file generated from bactdating
#' @param coltime_range range of collection time
#' @param divtime_range range of divergence time
#' @param distance_range range of the distance
#' @return pairwise matrices
#' @export
RR_matrix = function(meta_table, bactdate_tree, coltime_range = 1, divtime_range = 50, distance_range = 100){
  lane.names <- meta_table$lane_id
  
  vector_lineage = meta_table$GPSC_PoPUNK2
  vector_location = meta_table$REGION
  vector_longitude <- meta_table$Longitude
  vector_latitude <- meta_table$Latitude
  vector_coltime = meta_table$Year_collection
  vector_coltime = vector_coltime + runif(length(vector_coltime), min = -0.01, max = 0.01)
  
  lineage_mat = abs(outer(vector_lineage, vector_lineage, "=="))
  diag(lineage_mat) <- NA
  colnames(lineage_mat) = lane.names
  rownames(lineage_mat) = lane.names
  
  location_mat = abs(outer(vector_location, vector_location, "=="))
  diag(geo_mat) <- NA
  colnames(geo_mat) = lane.names
  rownames(geo_mat) = lane.names
  
  lonlat_list1 = data.frame(longitude = vector_longitude, 
                            latitude = vector_latitude)
  lonlat_list2 = data.frame(longitude = vector_longitude, 
                            latitude = vector_latitude)
  distance_mat = distm(lonlat_list1[,c("longitude","latitude")], lonlat_list2[,c("longitude","latitude")], fun = distHaversine)
  distance_mat = distance_mat / 1000 ## change to km
  distance_mat[distance_mat==0] <- min(distance_mat[distance_mat!=0]) ## set minimal distance
  diag(distance_mat) = NA
  colnames(distance_mat) = lane.names
  rownames(distance_mat) = lane.names
  distance_mat = (distance_mat > 0)*(distance_mat <= distance_range) ## within 100 km
  
  coltime_mat = abs(outer(vector_coltime, vector_coltime, "-"))
  diag(coltime_mat) <- NA
  colnames(coltime_mat) = lane.names
  rownames(coltime_mat) = lane.names
  coltime_mat = (coltime_mat > 0)*(coltime_mat <= coltime_range) ## within a year
  
  dtime.mat <- cophenetic.phylo(bactdate_tree) ## cophenetic.phylo: compute the pairwise distance between the pairs of tips from a phlyogenetic tree 
  diag(dtime.mat) <- NA
  divtime_mat <- (dtime.mat-coltime_mat)/2
  divtime_mat = (divtime_mat > 0)*(divtime_mat <= divtime_range) ## diverge within 50 years
  
  res_list = list("pairwise_lineage_matrix" = lineage_mat, 
                  "pairwise_location_matrix" = location_mat,
                  "paireise_distance_matrix" = distance_mat,
                  "pairwise_coltime_matrix" = coltime_mat, 
                  "pairwise_divtime_matrix" = divtime_mat)
  return(res_list)
}


#' Generate Pairwise Matrix for Relative Risk Calculation
#' 
#' This function generates pairwise matrices from metadata file. 
#'
#' @param x selected index 
#' @param geo_matrix pairwise geographical matrix generated by RR_matrix() function
#' @param colyear_matrix pairwise collection year matrix generated by RR_matrix() function
#' @param strain_matrix pairwise lineage matrix generated by RR_matrix() function
#' @return relative risk
#' @export
ratio_bootstrap <- function(x, geo_matrix, colyear_matrix, strain_matrix){
  geo_mat.tmp = geo_matrix[x,x]       #pairwise geolocation matrix, subsetting by subsampling
  time_mat.tmp = colyear_matrix[x,x]  #pairwise collection year matrix
  strain_mat.tmp = strain_matrix[x,x] #pairwise lineage matrix
  tmp = geo_mat.tmp * time_mat.tmp    #dot product
  tmp[which(tmp==0)] = NA
  
  tmp2 = (1-geo_mat.tmp) * time_mat.tmp
  tmp2[which(tmp2 == 0)] = NA
  
  a = sum(tmp*strain_mat.tmp, na.rm = T)    #counts of all the isolates in same location, same lineage, same collection year
  b = sum(tmp, na.rm = T)                   #counts of all the isolates in same location and same collection year
  c = sum(tmp2*strain_mat.tmp, na.rm = T)   #counts of all the isolates in different locations, same lineage, same collection year
  d = sum(tmp2, na.rm = T)                  #counts of all the isolates in different locations and same collection time
  rr = (a/b)/(c/d)
  if (max(rr, na.rm = T) > 1E10){
    rr = ((a+1)/(b+1))/((c+1)/(d+1))
  }
  if (is.na(rr) == T | rr[1]==0){
    rr = ((a+1)/b)/(c/d)
  }
  return(rr)
}

#' Generate Pairwise Matrix for Relative Risk Calculation
#' 
#' This function generates pairwise matrices from metadata file. 
#'
#' @param geo_matrix pairwise geographical matrix generated by RR_matrix() function
#' @param colyear_matrix pairwise collection year matrix generated by RR_matrix() function
#' @param strain_matrix pairwise lineage matrix generated by RR_matrix() function
#' @param metadataset metadata
#' @return relative risk with bootstrap
#' @export
RelativeRisk = function(geo_matrix, colyear_matrix, strain_matrix, metadataset){
  nseq = nrow(strain_matrix)
  nboot = 20
  boot.out = matrix(NA, 1, nboot+1) # create output matrix 1x(nboot+1)
  
  for (j in 1:nboot){
    ## subsample each region ##
    selectedSeqs = NULL
    uni_region_vec = unique(metadataset$REGION)
    region_vec = metadataset$REGION
    
    for (i in 1:length(uni_region_vec)){
      a = which(region_vec==uni_region_vec[i])        #select a certain region (index)
      b = sample(a, min(70, length(a)), replace = F)  #subsample without replacement (index)
      selectedSeqs = c(selectedSeqs, b)               #collect selected samples in a certain region (index)
    }
    tmp = sample(selectedSeqs, replace = T)           #tmp is a set of selected sample from a certain region
    ## end subsampling
    rr = ratio_bootstrap(x=tmp, geo_matrix = geo_matrix, colyear_matrix = colyear_matrix, strain_matrix = strain_matrix)
    boot.out[,j] = rr                                 #write the rr in the bootstrap matrix
    print[j] #print which bootstrap you are on 
  }
  
  boot.ci = quantile(boot.out, probs = c(0.025, 0.975), na.rm=T) #calculate confidence interval
  boot.med = quantile(boot.out, probs = c(0.5), na.rm=T) #calculate the median
  
  mat = matrix(nrow=1, ncol=3)
  mat[1,1] = boot.med
  mat[1,2] = boot.ci[1]
  mat[1,3] = boot.ci[2]
  mat = as.data.table(mat)
  
  colnames(mat) = c("RR_mean", "RR_lower_ci", "RR_upper_ci")
  mat$RR_mean = as.numeric(mat$RR_mean)
  mat$RR_lower_ci = as.numeric(mat$RR_lower_ci)
  mat$RR_upper_ci = as.numeric(mat$upper_ci)
  
  return(mat)
  
  p = ggplot(data=mat, aes(x=1, y=RR_mean)) +
    geom_boxplot(width = 0.01)
    geom_errorbar(aes(ymin = lower_ci))
}

#' Generate Pairwise Matrix for Relative Risk Calculation
#' 
#' This function generates pairwise matrices from metadata file. 
#'
#' @param rrData relative risk generated by RelativeRisk()
#' @param RRplotTitle name of the plot
#' @return relative risk plot
#' @export
PltRR = function(rrData, RRplotTitle){
  p = ggplot(data=rrData, aes(x=1, y=RR_mean))+
    geom_boxplot(width=0.01)
    geom_errorbar( aes(ymin = RR_lower_ci, ymax = RR_upper_ci), width=0.01,alpha=0.9) +
    geom_hline(yintercept=1, linetype="dashed", color = "red") + ##dashed line at 1
    scale_y_log10()+
    ylab("Risk Ratio")+
    ggtitle(scale_y_log10()+
              ylab("Risk Ratio")+
              ggtitle(RRplotTitle)+
              theme(axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.title.x = element_blank()))+
    theme(axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.title.x = element_blank())
    
  return(p)
}

